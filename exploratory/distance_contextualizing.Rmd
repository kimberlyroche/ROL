---
title: "Contextualizing distances"
author: "Kim Roche"
date: "7/1/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Libraries, functions, and data loading

```{r cars}
suppressMessages(library(ROL))
suppressMessages(library(phyloseq))
suppressMessages(library(dplyr))
suppressMessages(library(ggplot2))
suppressMessages(library(abind))
suppressMessages(library(matrixsampling))

calc_shared_sign <- function(A, B) {
  vecA <- c(A[upper.tri(A, diag = F)])
  vecB <- c(B[upper.tri(B, diag = F)])
  sum(sign(vecA) == sign(vecB))/length(vecA)
}

# load MAP estimates of covariance
setwd("..") # for load_MAP_estimates
Sigmas <- load_MAP_estimates(tax_level = "ASV", logratio = "clr")
# convert these to correlations
Sigmas <- lapply(Sigmas, function(x) cov2cor(x)) # JOHANNES, THANK YOU
n_hosts <- length(Sigmas)
P <- dim(Sigmas[[1]])[1]
pairwise_combos <- P^2 - P^2/2 - P/2

# strip out the triangular portion of the correlation matrices, vectorize these, and put them in a matrix
# for later convenience
vectorized_Sigmas <- matrix(NA, n_hosts, pairwise_combos)
for(i in 1:n_hosts){
  vectorized_Sigmas[i,] <- Sigmas[[i]][upper.tri(Sigmas[[i]], diag = F)]
}

# get host primary social group assignments
data <- load_data(tax_level = "ASV")
labels <- list()
for(host in names(Sigmas)) {
  subdata <- subset_samples(data, sname == host)
  metadata <- sample_data(subdata)
  labels[[host]] <- names(which(table(metadata[["grp"]]) == max(table(metadata[["grp"]]))))[1]
}
```

## What's the proportion of shared correlation *sign* across hosts and between (primary) social groups?

```{r shared_sign}
shared_signs <- c()
for(i in 1:(n_hosts - 1)){
  for(j in (i + 1):n_hosts) {
    shared_signs <- c(shared_signs, calc_shared_sign(Sigmas[[i]], Sigmas[[j]]))
  }
}

df <- data.frame(x = c(), group = c())
for(i in 1:(n_hosts - 1)){
  for(j in (i + 1):n_hosts) {
    if(labels[[names(Sigmas)[i]]] == labels[[names(Sigmas)[j]]]) {
      df <- rbind(df, data.frame(x = calc_shared_sign(Sigmas[[i]], Sigmas[[j]]), group = labels[[names(Sigmas)[i]]]))
    } else {
      df <- rbind(df, data.frame(x = calc_shared_sign(Sigmas[[i]], Sigmas[[j]]), group = NA))
    }
  }
}

p_shared_sign <- ggplot(df) +
  geom_density(aes(x = x, color = group)) +
  xlim(c(0,1))
print(p_shared_sign)
```

## What's the distance between individuals in terms of their correlation sets?

```{r corr_dist}
max_dist <- dist(rbind(rep(1, pairwise_combos), rep(-1, pairwise_combos)))[1]

# just use Euclidean distance
df <- data.frame(x = c(dist(vectorized_Sigmas)))

p_dist <- ggplot(df, aes(x = x)) +
  geom_density() +
  xlim(c(0, max_dist)) +
  xlab("Euclidean distance over correlation pairs")
print(p_dist)
```

## A combined perspective

Can we simultaneously quantify: (1) How strong the evidence of associations is within hosts and (2) the degree of agreement between hosts?

### The strength of associations within hosts

```{r within_hosts}
strength_within_hosts <- function(host_vector, max_strength) {
  sum(abs(host_vector))/max_strength
}

df_within_hosts <- data.frame(x = apply(vectorized_Sigmas, 1, function(x) strength_within_hosts(x, pairwise_combos)),
                              host = names(Sigmas),
                              group = unlist(labels))

p_within_host <- ggplot(df_within_hosts, aes(x = x, color = group)) +
  geom_density() +
  xlim(c(0, 1)) +
  xlab("Correlation between host pairs")
print(p_within_host)
```

### The agreement between hosts

```{r between_hosts}
df_across_hosts <- data.frame(x = c(), host1 = c(), host2 = c(), group1 = c(), group2 = c(), shared_group = c())

for(i in 1:(n_hosts - 1)) {
  for(j in (i + 1):n_hosts) {
    shared_group <- NA
    grp1 <- unlist(labels[names(Sigmas)[i]])
    grp2 <- unlist(labels[names(Sigmas)[j]])
    if(grp1 == grp2) {
      shared_group <- grp1
    }
    df_across_hosts <- rbind(df_across_hosts, data.frame(x = cor(vectorized_Sigmas[i,], vectorized_Sigmas[j,]),
                                                         host1 = names(Sigmas)[i],
                                                         host2 = names(Sigmas)[j],
                                                         group1 = grp1,
                                                         group2 = grp2,
                                                         shared_group = shared_group))
  }
}

p_between <- ggplot(df_across_hosts, aes(x = x, color = shared_group)) +
  geom_density() +
  xlim(c(0, 1)) +
  xlab("Correlation between host pairs")
print(p_between)
```

### Putting this together

```{r combined}
df_combined <- data.frame(x = mean(df_within_hosts$x), y = mean(df_across_hosts$x), group = "all_baboons")

for(group in unlist(unique(labels))) {
  df_combined <- rbind(df_combined,
                       data.frame(x = mean(df_within_hosts[df_within_hosts$group == group,]$x),
                                  y = mean(df_across_hosts[df_across_hosts$group1 == group & df_across_hosts$group2 == group,]$x), group = group))
}

p_combo <- ggplot(df_combined) +
  geom_point(aes(x = x, y = y, color = group), size = 2) +
  xlim(c(0,1)) +
  ylim(c(-0.1,1)) +
  xlab("avg. strength of associations (within hosts)") +
  ylab("avg. agreement between hosts")
print(p_combo)
```

## Comparing to Lemur data

```{r lemur}
CON_cor <- readRDS("C:/Users/kim/Documents/lemur_bornbusch/CON_Sigma.rds")
ABX_cor <- readRDS("C:/Users/kim/Documents/lemur_bornbusch/ABX_Sigma.rds")
ABXFT_cor <- readRDS("C:/Users/kim/Documents/lemur_bornbusch/ABXFT_Sigma.rds")

P_lemur <- dim(CON_cor)[1]
lemur_combos <- P_lemur^2 - P_lemur^2/2 - P_lemur/2

vectorized_lemurs <- matrix(NA, 3, lemur_combos)
vectorized_lemurs[1,] <- CON_cor[upper.tri(CON_cor, diag = F)]
vectorized_lemurs[2,] <- ABX_cor[upper.tri(ABX_cor, diag = F)]
vectorized_lemurs[3,] <- ABXFT_cor[upper.tri(ABXFT_cor, diag = F)]

# calculate within measurement
mean_within <- mean(strength_within_hosts(vectorized_lemurs[1,], lemur_combos),
                    strength_within_hosts(vectorized_lemurs[2,], lemur_combos),
                    strength_within_hosts(vectorized_lemurs[3,], lemur_combos))

agreement_between <- mean(cor(vectorized_lemurs[1,], vectorized_lemurs[2,]),
                          cor(vectorized_lemurs[1,], vectorized_lemurs[3,]),
                          cor(vectorized_lemurs[2,], vectorized_lemurs[3,]))

df_combined_lemur <- rbind(df_combined, data.frame(x = mean_within, y = agreement_between, group = "all_lemurs"))

p_combo <- ggplot(df_combined_lemur) +
  geom_point(aes(x = x, y = y, color = group), size = 2) +
  xlim(c(0,1)) +
  ylim(c(-0.1,1)) +
  xlab("avg. strength of associations (within hosts)") +
  ylab("avg. agreement between hosts")
print(p_combo)
```

## Simulating to get a sense of the extremes

Let's simulate 4 conditions and see where they end up on this "map"
1) Strong correlation, little agreement
2) Strong correlation, strong agreement

```{r sim1}
# this simulates case 1
simulate_correlations <- function(upsilon, Xi, test_hosts = 10) {
  test_correlations <- matrix(NA, test_hosts, pairwise_combos)
  for(i in 1:test_hosts) {
    sample_covmat <- cov2cor(rinvwishart(1, upsilon, Xi*(upsilon - P - 1))[,,1])
    test_correlations[i,] <- sample_covmat[upper.tri(sample_covmat, diag = F)]
  }
  test_correlations
}

test_correlations <- simulate_correlations(upsilon = P + 20, Xi = diag(P))

mean_within <- mean(apply(test_correlations, 1, function(x) strength_within_hosts(x, pairwise_combos)))
mean_across <- c()
for(i in 1:(nrow(test_correlations) - 1)) {
  for(j in (i + 1):nrow(test_correlations)) {
    mean_across <- c(mean_across, cor(test_correlations[i,], test_correlations[j,]))
  }
}
mean_across <- mean(mean_across)

df_combined_sim1 <- rbind(df_combined, data.frame(x = mean_within, y = agreement_between, group = "simulated"))

p_combo <- ggplot(df_combined_sim1) +
  geom_point(aes(x = x, y = y, color = group), size = 2) +
  xlim(c(0,1)) +
  ylim(c(-0.1,1)) +
  xlab("avg. strength of associations (within hosts)") +
  ylab("avg. agreement between hosts")
print(p_combo)
```

## Binning pairwise relationships according to Duiker

What happens if we bin pairwise microbial relationships according to their strength in a reference individual and plot these binned sets on our "map"? (Choosing a reference individual gets around the fact that if we were to bin for strength across individuals we'd be asking a ciruclar question once we evaluated these bins on *agreement between hosts.*)

```{r bin_dui}
vectorized_DUI <- vectorized_Sigmas[which(names(Sigmas) == "DUI"),]
ecdf <- sort(abs(vectorized_DUI))
# separate into quantiles
boundaries <- quantile(ecdf, probs = seq(from = 0, to = 1, by = 0.1))

get_col_idx <- function(vec, lower_boundary, upper_boundary) {
  which(abs(vec) >= lower_boundary & abs(vec) < upper_boundary)
}

# col_idx are the column indices of pairs of microbes to consider here
calc_map_xy <- function(vectorized_Sigmas, col_idx) {
  within_score <- mean(apply(abs(vectorized_Sigmas[,col_idx]), 1, mean))
  between_score <- mean(apply(combn(1:nrow(vectorized_Sigmas), m = 2), 2, function(x) {
    cor(vectorized_Sigmas[x[1],col_idx], vectorized_Sigmas[x[2],col_idx])
  }))
  return(list(x = within_score, y = between_score))
}

plot_df <- data.frame(x = c(), y = c(), label = c())
for(i in 1:(length(boundaries)-1)) {
  point <- calc_map_xy(vectorized_Sigmas, get_col_idx(vectorized_DUI, boundaries[i], boundaries[i+1]))
  plot_df <- rbind(plot_df, data.frame(x = point$x, y = point$y, label = names(boundaries)[i+1]))
}

p_quantiles <- ggplot(plot_df) +
  geom_point(aes(x = x, y = y, color = label)) +
  xlim(c(0, 1)) +
  ylim(c(-0.1, 1)) +
  xlab("avg. strength of associations (within hosts)") +
  ylab("avg. agreement between hosts")
print(p_quantiles)
```











